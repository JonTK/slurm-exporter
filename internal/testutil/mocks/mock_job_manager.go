// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	"github.com/jontk/slurm-client"
	mock "github.com/stretchr/testify/mock"
)

// MockJobManager is an autogenerated mock type for the JobManager type
type MockJobManager struct {
	mock.Mock
}

// Allocate provides a mock function with given fields: ctx, req
func (_m *MockJobManager) Allocate(ctx context.Context, req *slurm.JobAllocateRequest) (*slurm.JobAllocateResponse, error) {
	ret := _m.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Allocate")
	}

	var r0 *slurm.JobAllocateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.JobAllocateRequest) (*slurm.JobAllocateResponse, error)); ok {
		return rf(ctx, req)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.JobAllocateRequest) *slurm.JobAllocateResponse); ok {
		r0 = rf(ctx, req)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobAllocateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.JobAllocateRequest) error); ok {
		r1 = rf(ctx, req)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AnalyzeBatchJobs provides a mock function with given fields: ctx, jobIDs, opts
func (_m *MockJobManager) AnalyzeBatchJobs(ctx context.Context, jobIDs []string, opts *slurm.BatchAnalysisOptions) (*slurm.BatchJobAnalysis, error) {
	ret := _m.Called(ctx, jobIDs, opts)

	if len(ret) == 0 {
		panic("no return value specified for AnalyzeBatchJobs")
	}

	var r0 *slurm.BatchJobAnalysis
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, *slurm.BatchAnalysisOptions) (*slurm.BatchJobAnalysis, error)); ok {
		return rf(ctx, jobIDs, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string, *slurm.BatchAnalysisOptions) *slurm.BatchJobAnalysis); ok {
		r0 = rf(ctx, jobIDs, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.BatchJobAnalysis)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string, *slurm.BatchAnalysisOptions) error); ok {
		r1 = rf(ctx, jobIDs, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Cancel provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) Cancel(ctx context.Context, jobID string) error {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Cancel")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GenerateEfficiencyReport provides a mock function with given fields: ctx, opts
func (_m *MockJobManager) GenerateEfficiencyReport(ctx context.Context, opts *slurm.ReportOptions) (*slurm.EfficiencyReport, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for GenerateEfficiencyReport")
	}

	var r0 *slurm.EfficiencyReport
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ReportOptions) (*slurm.EfficiencyReport, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ReportOptions) *slurm.EfficiencyReport); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.EfficiencyReport)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.ReportOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) Get(ctx context.Context, jobID string) (*slurm.Job, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *slurm.Job
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.Job, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.Job); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.Job)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobCPUAnalytics provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobCPUAnalytics(ctx context.Context, jobID string) (*slurm.CPUAnalytics, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobCPUAnalytics")
	}

	var r0 *slurm.CPUAnalytics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.CPUAnalytics, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.CPUAnalytics); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.CPUAnalytics)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobComprehensiveAnalytics provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobComprehensiveAnalytics(ctx context.Context, jobID string) (*slurm.JobComprehensiveAnalytics, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobComprehensiveAnalytics")
	}

	var r0 *slurm.JobComprehensiveAnalytics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.JobComprehensiveAnalytics, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.JobComprehensiveAnalytics); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobComprehensiveAnalytics)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobEfficiency provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobEfficiency(ctx context.Context, jobID string) (*slurm.ResourceUtilization, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobEfficiency")
	}

	var r0 *slurm.ResourceUtilization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.ResourceUtilization, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.ResourceUtilization); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.ResourceUtilization)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobIOAnalytics provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobIOAnalytics(ctx context.Context, jobID string) (*slurm.IOAnalytics, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobIOAnalytics")
	}

	var r0 *slurm.IOAnalytics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.IOAnalytics, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.IOAnalytics); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.IOAnalytics)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobLiveMetrics provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobLiveMetrics(ctx context.Context, jobID string) (*slurm.JobLiveMetrics, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobLiveMetrics")
	}

	var r0 *slurm.JobLiveMetrics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.JobLiveMetrics, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.JobLiveMetrics); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobLiveMetrics)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobMemoryAnalytics provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobMemoryAnalytics(ctx context.Context, jobID string) (*slurm.MemoryAnalytics, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobMemoryAnalytics")
	}

	var r0 *slurm.MemoryAnalytics
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.MemoryAnalytics, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.MemoryAnalytics); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.MemoryAnalytics)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobPerformance provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobPerformance(ctx context.Context, jobID string) (*slurm.JobPerformance, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobPerformance")
	}

	var r0 *slurm.JobPerformance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.JobPerformance, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.JobPerformance); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobPerformance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobPerformanceHistory provides a mock function with given fields: ctx, jobID, opts
func (_m *MockJobManager) GetJobPerformanceHistory(ctx context.Context, jobID string, opts *slurm.PerformanceHistoryOptions) (*slurm.JobPerformanceHistory, error) {
	ret := _m.Called(ctx, jobID, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetJobPerformanceHistory")
	}

	var r0 *slurm.JobPerformanceHistory
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.PerformanceHistoryOptions) (*slurm.JobPerformanceHistory, error)); ok {
		return rf(ctx, jobID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.PerformanceHistoryOptions) *slurm.JobPerformanceHistory); ok {
		r0 = rf(ctx, jobID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobPerformanceHistory)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.PerformanceHistoryOptions) error); ok {
		r1 = rf(ctx, jobID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobResourceTrends provides a mock function with given fields: ctx, jobID, opts
func (_m *MockJobManager) GetJobResourceTrends(ctx context.Context, jobID string, opts *slurm.ResourceTrendsOptions) (*slurm.JobResourceTrends, error) {
	ret := _m.Called(ctx, jobID, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetJobResourceTrends")
	}

	var r0 *slurm.JobResourceTrends
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ResourceTrendsOptions) (*slurm.JobResourceTrends, error)); ok {
		return rf(ctx, jobID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ResourceTrendsOptions) *slurm.JobResourceTrends); ok {
		r0 = rf(ctx, jobID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobResourceTrends)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.ResourceTrendsOptions) error); ok {
		r1 = rf(ctx, jobID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobStepAPIData provides a mock function with given fields: ctx, jobID, stepID
func (_m *MockJobManager) GetJobStepAPIData(ctx context.Context, jobID string, stepID string) (*slurm.JobStepAPIData, error) {
	ret := _m.Called(ctx, jobID, stepID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobStepAPIData")
	}

	var r0 *slurm.JobStepAPIData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.JobStepAPIData, error)); ok {
		return rf(ctx, jobID, stepID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.JobStepAPIData); ok {
		r0 = rf(ctx, jobID, stepID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobStepAPIData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, jobID, stepID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobStepDetails provides a mock function with given fields: ctx, jobID, stepID
func (_m *MockJobManager) GetJobStepDetails(ctx context.Context, jobID string, stepID string) (*slurm.JobStepDetails, error) {
	ret := _m.Called(ctx, jobID, stepID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobStepDetails")
	}

	var r0 *slurm.JobStepDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.JobStepDetails, error)); ok {
		return rf(ctx, jobID, stepID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.JobStepDetails); ok {
		r0 = rf(ctx, jobID, stepID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobStepDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, jobID, stepID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobStepUtilization provides a mock function with given fields: ctx, jobID, stepID
func (_m *MockJobManager) GetJobStepUtilization(ctx context.Context, jobID string, stepID string) (*slurm.JobStepUtilization, error) {
	ret := _m.Called(ctx, jobID, stepID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobStepUtilization")
	}

	var r0 *slurm.JobStepUtilization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.JobStepUtilization, error)); ok {
		return rf(ctx, jobID, stepID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.JobStepUtilization); ok {
		r0 = rf(ctx, jobID, stepID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobStepUtilization)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, jobID, stepID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobStepsFromAccounting provides a mock function with given fields: ctx, jobID, opts
func (_m *MockJobManager) GetJobStepsFromAccounting(ctx context.Context, jobID string, opts *slurm.AccountingQueryOptions) (*slurm.AccountingJobSteps, error) {
	ret := _m.Called(ctx, jobID, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetJobStepsFromAccounting")
	}

	var r0 *slurm.AccountingJobSteps
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.AccountingQueryOptions) (*slurm.AccountingJobSteps, error)); ok {
		return rf(ctx, jobID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.AccountingQueryOptions) *slurm.AccountingJobSteps); ok {
		r0 = rf(ctx, jobID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountingJobSteps)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.AccountingQueryOptions) error); ok {
		r1 = rf(ctx, jobID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetJobUtilization provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) GetJobUtilization(ctx context.Context, jobID string) (*slurm.JobUtilization, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for GetJobUtilization")
	}

	var r0 *slurm.JobUtilization
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.JobUtilization, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.JobUtilization); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobUtilization)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPerformanceTrends provides a mock function with given fields: ctx, opts
func (_m *MockJobManager) GetPerformanceTrends(ctx context.Context, opts *slurm.TrendAnalysisOptions) (*slurm.PerformanceTrends, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetPerformanceTrends")
	}

	var r0 *slurm.PerformanceTrends
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.TrendAnalysisOptions) (*slurm.PerformanceTrends, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.TrendAnalysisOptions) *slurm.PerformanceTrends); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.PerformanceTrends)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.TrendAnalysisOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetStepAccountingData provides a mock function with given fields: ctx, jobID, stepID
func (_m *MockJobManager) GetStepAccountingData(ctx context.Context, jobID string, stepID string) (*slurm.StepAccountingRecord, error) {
	ret := _m.Called(ctx, jobID, stepID)

	if len(ret) == 0 {
		panic("no return value specified for GetStepAccountingData")
	}

	var r0 *slurm.StepAccountingRecord
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.StepAccountingRecord, error)); ok {
		return rf(ctx, jobID, stepID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.StepAccountingRecord); ok {
		r0 = rf(ctx, jobID, stepID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.StepAccountingRecord)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, jobID, stepID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserEfficiencyTrends provides a mock function with given fields: ctx, userID, opts
func (_m *MockJobManager) GetUserEfficiencyTrends(ctx context.Context, userID string, opts *slurm.EfficiencyTrendOptions) (*slurm.UserEfficiencyTrends, error) {
	ret := _m.Called(ctx, userID, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetUserEfficiencyTrends")
	}

	var r0 *slurm.UserEfficiencyTrends
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.EfficiencyTrendOptions) (*slurm.UserEfficiencyTrends, error)); ok {
		return rf(ctx, userID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.EfficiencyTrendOptions) *slurm.UserEfficiencyTrends); ok {
		r0 = rf(ctx, userID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserEfficiencyTrends)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.EfficiencyTrendOptions) error); ok {
		r1 = rf(ctx, userID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWorkflowPerformance provides a mock function with given fields: ctx, workflowID, opts
func (_m *MockJobManager) GetWorkflowPerformance(ctx context.Context, workflowID string, opts *slurm.WorkflowAnalysisOptions) (*slurm.WorkflowPerformance, error) {
	ret := _m.Called(ctx, workflowID, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetWorkflowPerformance")
	}

	var r0 *slurm.WorkflowPerformance
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.WorkflowAnalysisOptions) (*slurm.WorkflowPerformance, error)); ok {
		return rf(ctx, workflowID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.WorkflowAnalysisOptions) *slurm.WorkflowPerformance); ok {
		r0 = rf(ctx, workflowID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.WorkflowPerformance)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.WorkflowAnalysisOptions) error); ok {
		r1 = rf(ctx, workflowID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Hold provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) Hold(ctx context.Context, jobID string) error {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Hold")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// List provides a mock function with given fields: ctx, opts
func (_m *MockJobManager) List(ctx context.Context, opts *slurm.ListJobsOptions) (*slurm.JobList, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *slurm.JobList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ListJobsOptions) (*slurm.JobList, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ListJobsOptions) *slurm.JobList); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.ListJobsOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobStepsFromSacct provides a mock function with given fields: ctx, jobID, opts
func (_m *MockJobManager) ListJobStepsFromSacct(ctx context.Context, jobID string, opts *slurm.SacctQueryOptions) (*slurm.SacctJobStepData, error) {
	ret := _m.Called(ctx, jobID, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListJobStepsFromSacct")
	}

	var r0 *slurm.SacctJobStepData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.SacctQueryOptions) (*slurm.SacctJobStepData, error)); ok {
		return rf(ctx, jobID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.SacctQueryOptions) *slurm.SacctJobStepData); ok {
		r0 = rf(ctx, jobID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.SacctJobStepData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.SacctQueryOptions) error); ok {
		r1 = rf(ctx, jobID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListJobStepsWithMetrics provides a mock function with given fields: ctx, jobID, opts
func (_m *MockJobManager) ListJobStepsWithMetrics(ctx context.Context, jobID string, opts *slurm.ListJobStepsOptions) (*slurm.JobStepMetricsList, error) {
	ret := _m.Called(ctx, jobID, opts)

	if len(ret) == 0 {
		panic("no return value specified for ListJobStepsWithMetrics")
	}

	var r0 *slurm.JobStepMetricsList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ListJobStepsOptions) (*slurm.JobStepMetricsList, error)); ok {
		return rf(ctx, jobID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ListJobStepsOptions) *slurm.JobStepMetricsList); ok {
		r0 = rf(ctx, jobID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobStepMetricsList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.ListJobStepsOptions) error); ok {
		r1 = rf(ctx, jobID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Notify provides a mock function with given fields: ctx, jobID, message
func (_m *MockJobManager) Notify(ctx context.Context, jobID string, message string) error {
	ret := _m.Called(ctx, jobID, message)

	if len(ret) == 0 {
		panic("no return value specified for Notify")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, jobID, message)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Release provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) Release(ctx context.Context, jobID string) error {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Release")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Requeue provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) Requeue(ctx context.Context, jobID string) error {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Requeue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, jobID)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Signal provides a mock function with given fields: ctx, jobID, signal
func (_m *MockJobManager) Signal(ctx context.Context, jobID string, signal string) error {
	ret := _m.Called(ctx, jobID, signal)

	if len(ret) == 0 {
		panic("no return value specified for Signal")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, jobID, signal)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Steps provides a mock function with given fields: ctx, jobID
func (_m *MockJobManager) Steps(ctx context.Context, jobID string) (*slurm.JobStepList, error) {
	ret := _m.Called(ctx, jobID)

	if len(ret) == 0 {
		panic("no return value specified for Steps")
	}

	var r0 *slurm.JobStepList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.JobStepList, error)); ok {
		return rf(ctx, jobID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.JobStepList); ok {
		r0 = rf(ctx, jobID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobStepList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, jobID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Submit provides a mock function with given fields: ctx, job
func (_m *MockJobManager) Submit(ctx context.Context, job *slurm.JobSubmission) (*slurm.JobSubmitResponse, error) {
	ret := _m.Called(ctx, job)

	if len(ret) == 0 {
		panic("no return value specified for Submit")
	}

	var r0 *slurm.JobSubmitResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.JobSubmission) (*slurm.JobSubmitResponse, error)); ok {
		return rf(ctx, job)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.JobSubmission) *slurm.JobSubmitResponse); ok {
		r0 = rf(ctx, job)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobSubmitResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.JobSubmission) error); ok {
		r1 = rf(ctx, job)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, jobID, update
func (_m *MockJobManager) Update(ctx context.Context, jobID string, update *slurm.JobUpdate) error {
	ret := _m.Called(ctx, jobID, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.JobUpdate) error); ok {
		r0 = rf(ctx, jobID, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Watch provides a mock function with given fields: ctx, opts
func (_m *MockJobManager) Watch(ctx context.Context, opts *slurm.WatchJobsOptions) (<-chan slurm.JobEvent, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for Watch")
	}

	var r0 <-chan slurm.JobEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.WatchJobsOptions) (<-chan slurm.JobEvent, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.WatchJobsOptions) <-chan slurm.JobEvent); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan slurm.JobEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.WatchJobsOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WatchJobMetrics provides a mock function with given fields: ctx, jobID, opts
func (_m *MockJobManager) WatchJobMetrics(ctx context.Context, jobID string, opts *slurm.WatchMetricsOptions) (<-chan slurm.JobMetricsEvent, error) {
	ret := _m.Called(ctx, jobID, opts)

	if len(ret) == 0 {
		panic("no return value specified for WatchJobMetrics")
	}

	var r0 <-chan slurm.JobMetricsEvent
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.WatchMetricsOptions) (<-chan slurm.JobMetricsEvent, error)); ok {
		return rf(ctx, jobID, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.WatchMetricsOptions) <-chan slurm.JobMetricsEvent); ok {
		r0 = rf(ctx, jobID, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(<-chan slurm.JobMetricsEvent)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.WatchMetricsOptions) error); ok {
		r1 = rf(ctx, jobID, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockJobManager creates a new instance of MockJobManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockJobManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockJobManager {
	mock := &MockJobManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
