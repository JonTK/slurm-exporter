// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	"github.com/jontk/slurm-client"
	mock "github.com/stretchr/testify/mock"
)

// MockUserManager is an autogenerated mock type for the UserManager type
type MockUserManager struct {
	mock.Mock
}

// CalculateJobPriority provides a mock function with given fields: ctx, userName, jobSubmission
func (_m *MockUserManager) CalculateJobPriority(ctx context.Context, userName string, jobSubmission *slurm.JobSubmission) (*slurm.JobPriorityInfo, error) {
	ret := _m.Called(ctx, userName, jobSubmission)

	if len(ret) == 0 {
		panic("no return value specified for CalculateJobPriority")
	}

	var r0 *slurm.JobPriorityInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.JobSubmission) (*slurm.JobPriorityInfo, error)); ok {
		return rf(ctx, userName, jobSubmission)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.JobSubmission) *slurm.JobPriorityInfo); ok {
		r0 = rf(ctx, userName, jobSubmission)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.JobPriorityInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.JobSubmission) error); ok {
		r1 = rf(ctx, userName, jobSubmission)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: ctx, user
func (_m *MockUserManager) Create(ctx context.Context, user *slurm.UserCreate) (*slurm.UserCreateResponse, error) {
	ret := _m.Called(ctx, user)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *slurm.UserCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.UserCreate) (*slurm.UserCreateResponse, error)); ok {
		return rf(ctx, user)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.UserCreate) *slurm.UserCreateResponse); ok {
		r0 = rf(ctx, user)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.UserCreate) error); ok {
		r1 = rf(ctx, user)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssociation provides a mock function with given fields: ctx, accountName, opts
func (_m *MockUserManager) CreateAssociation(ctx context.Context, accountName string, opts *slurm.AssociationOptions) (*slurm.AssociationCreateResponse, error) {
	ret := _m.Called(ctx, accountName, opts)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssociation")
	}

	var r0 *slurm.AssociationCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.AssociationOptions) (*slurm.AssociationCreateResponse, error)); ok {
		return rf(ctx, accountName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.AssociationOptions) *slurm.AssociationCreateResponse); ok {
		r0 = rf(ctx, accountName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AssociationCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.AssociationOptions) error); ok {
		r1 = rf(ctx, accountName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) Delete(ctx context.Context, userName string) error {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, userName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) Get(ctx context.Context, userName string) (*slurm.User, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *slurm.User
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.User, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.User); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.User)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBulkAccountUsers provides a mock function with given fields: ctx, accountNames
func (_m *MockUserManager) GetBulkAccountUsers(ctx context.Context, accountNames []string) (map[string][]*slurm.UserAccountAssociation, error) {
	ret := _m.Called(ctx, accountNames)

	if len(ret) == 0 {
		panic("no return value specified for GetBulkAccountUsers")
	}

	var r0 map[string][]*slurm.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (map[string][]*slurm.UserAccountAssociation, error)); ok {
		return rf(ctx, accountNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) map[string][]*slurm.UserAccountAssociation); ok {
		r0 = rf(ctx, accountNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*slurm.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, accountNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetBulkUserAccounts provides a mock function with given fields: ctx, userNames
func (_m *MockUserManager) GetBulkUserAccounts(ctx context.Context, userNames []string) (map[string][]*slurm.UserAccount, error) {
	ret := _m.Called(ctx, userNames)

	if len(ret) == 0 {
		panic("no return value specified for GetBulkUserAccounts")
	}

	var r0 map[string][]*slurm.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, []string) (map[string][]*slurm.UserAccount, error)); ok {
		return rf(ctx, userNames)
	}
	if rf, ok := ret.Get(0).(func(context.Context, []string) map[string][]*slurm.UserAccount); ok {
		r0 = rf(ctx, userNames)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string][]*slurm.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, []string) error); ok {
		r1 = rf(ctx, userNames)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserAccountAssociations provides a mock function with given fields: ctx, userName, opts
func (_m *MockUserManager) GetUserAccountAssociations(ctx context.Context, userName string, opts *slurm.ListUserAccountAssociationsOptions) ([]*slurm.UserAccountAssociation, error) {
	ret := _m.Called(ctx, userName, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccountAssociations")
	}

	var r0 []*slurm.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ListUserAccountAssociationsOptions) ([]*slurm.UserAccountAssociation, error)); ok {
		return rf(ctx, userName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ListUserAccountAssociationsOptions) []*slurm.UserAccountAssociation); ok {
		r0 = rf(ctx, userName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*slurm.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.ListUserAccountAssociationsOptions) error); ok {
		r1 = rf(ctx, userName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserAccounts provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserAccounts(ctx context.Context, userName string) ([]*slurm.UserAccount, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserAccounts")
	}

	var r0 []*slurm.UserAccount
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*slurm.UserAccount, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*slurm.UserAccount); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*slurm.UserAccount)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserDefaultAccount provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserDefaultAccount(ctx context.Context, userName string) (*slurm.Account, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserDefaultAccount")
	}

	var r0 *slurm.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.Account, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.Account); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserFairShare provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserFairShare(ctx context.Context, userName string) (*slurm.UserFairShare, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserFairShare")
	}

	var r0 *slurm.UserFairShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.UserFairShare, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.UserFairShare); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserFairShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetUserQuotas provides a mock function with given fields: ctx, userName
func (_m *MockUserManager) GetUserQuotas(ctx context.Context, userName string) (*slurm.UserQuota, error) {
	ret := _m.Called(ctx, userName)

	if len(ret) == 0 {
		panic("no return value specified for GetUserQuotas")
	}

	var r0 *slurm.UserQuota
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.UserQuota, error)); ok {
		return rf(ctx, userName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.UserQuota); ok {
		r0 = rf(ctx, userName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserQuota)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, userName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, opts
func (_m *MockUserManager) List(ctx context.Context, opts *slurm.ListUsersOptions) (*slurm.UserList, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *slurm.UserList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ListUsersOptions) (*slurm.UserList, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ListUsersOptions) *slurm.UserList); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.ListUsersOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, userName, update
func (_m *MockUserManager) Update(ctx context.Context, userName string, update *slurm.UserUpdate) error {
	ret := _m.Called(ctx, userName, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.UserUpdate) error); ok {
		r0 = rf(ctx, userName, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateUserAccountAccess provides a mock function with given fields: ctx, userName, accountName
func (_m *MockUserManager) ValidateUserAccountAccess(ctx context.Context, userName string, accountName string) (*slurm.UserAccessValidation, error) {
	ret := _m.Called(ctx, userName, accountName)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUserAccountAccess")
	}

	var r0 *slurm.UserAccessValidation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.UserAccessValidation, error)); ok {
		return rf(ctx, userName, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.UserAccessValidation); ok {
		r0 = rf(ctx, userName, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserAccessValidation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userName, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockUserManager creates a new instance of MockUserManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUserManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUserManager {
	mock := &MockUserManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
