// Code generated by mockery v2.53.5. DO NOT EDIT.

package mocks

import (
	context "context"

	"github.com/jontk/slurm-client"
	mock "github.com/stretchr/testify/mock"
)

// MockAccountManager is an autogenerated mock type for the AccountManager type
type MockAccountManager struct {
	mock.Mock
}

// Create provides a mock function with given fields: ctx, account
func (_m *MockAccountManager) Create(ctx context.Context, account *slurm.AccountCreate) (*slurm.AccountCreateResponse, error) {
	ret := _m.Called(ctx, account)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 *slurm.AccountCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.AccountCreate) (*slurm.AccountCreateResponse, error)); ok {
		return rf(ctx, account)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.AccountCreate) *slurm.AccountCreateResponse); ok {
		r0 = rf(ctx, account)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.AccountCreate) error); ok {
		r1 = rf(ctx, account)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAssociation provides a mock function with given fields: ctx, userName, accountName, opts
func (_m *MockAccountManager) CreateAssociation(ctx context.Context, userName string, accountName string, opts *slurm.AssociationOptions) (*slurm.AssociationCreateResponse, error) {
	ret := _m.Called(ctx, userName, accountName, opts)

	if len(ret) == 0 {
		panic("no return value specified for CreateAssociation")
	}

	var r0 *slurm.AssociationCreateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slurm.AssociationOptions) (*slurm.AssociationCreateResponse, error)); ok {
		return rf(ctx, userName, accountName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string, *slurm.AssociationOptions) *slurm.AssociationCreateResponse); ok {
		r0 = rf(ctx, userName, accountName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AssociationCreateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string, *slurm.AssociationOptions) error); ok {
		r1 = rf(ctx, userName, accountName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Delete provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) Delete(ctx context.Context, accountName string) error {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, accountName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Get provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) Get(ctx context.Context, accountName string) (*slurm.Account, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 *slurm.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.Account, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.Account); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountFairShare provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) GetAccountFairShare(ctx context.Context, accountName string) (*slurm.AccountFairShare, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountFairShare")
	}

	var r0 *slurm.AccountFairShare
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.AccountFairShare, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.AccountFairShare); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountFairShare)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountHierarchy provides a mock function with given fields: ctx, rootAccount
func (_m *MockAccountManager) GetAccountHierarchy(ctx context.Context, rootAccount string) (*slurm.AccountHierarchy, error) {
	ret := _m.Called(ctx, rootAccount)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountHierarchy")
	}

	var r0 *slurm.AccountHierarchy
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.AccountHierarchy, error)); ok {
		return rf(ctx, rootAccount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.AccountHierarchy); ok {
		r0 = rf(ctx, rootAccount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountHierarchy)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, rootAccount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountQuotaUsage provides a mock function with given fields: ctx, accountName, timeframe
func (_m *MockAccountManager) GetAccountQuotaUsage(ctx context.Context, accountName string, timeframe string) (*slurm.AccountUsage, error) {
	ret := _m.Called(ctx, accountName, timeframe)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountQuotaUsage")
	}

	var r0 *slurm.AccountUsage
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.AccountUsage, error)); ok {
		return rf(ctx, accountName, timeframe)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.AccountUsage); ok {
		r0 = rf(ctx, accountName, timeframe)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountUsage)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, accountName, timeframe)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountQuotas provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) GetAccountQuotas(ctx context.Context, accountName string) (*slurm.AccountQuota, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountQuotas")
	}

	var r0 *slurm.AccountQuota
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.AccountQuota, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.AccountQuota); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountQuota)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountUsers provides a mock function with given fields: ctx, accountName, opts
func (_m *MockAccountManager) GetAccountUsers(ctx context.Context, accountName string, opts *slurm.ListAccountUsersOptions) ([]*slurm.UserAccountAssociation, error) {
	ret := _m.Called(ctx, accountName, opts)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountUsers")
	}

	var r0 []*slurm.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ListAccountUsersOptions) ([]*slurm.UserAccountAssociation, error)); ok {
		return rf(ctx, accountName, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.ListAccountUsersOptions) []*slurm.UserAccountAssociation); ok {
		r0 = rf(ctx, accountName, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*slurm.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, *slurm.ListAccountUsersOptions) error); ok {
		r1 = rf(ctx, accountName, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAccountUsersWithPermissions provides a mock function with given fields: ctx, accountName, permissions
func (_m *MockAccountManager) GetAccountUsersWithPermissions(ctx context.Context, accountName string, permissions []string) ([]*slurm.UserAccountAssociation, error) {
	ret := _m.Called(ctx, accountName, permissions)

	if len(ret) == 0 {
		panic("no return value specified for GetAccountUsersWithPermissions")
	}

	var r0 []*slurm.UserAccountAssociation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) ([]*slurm.UserAccountAssociation, error)); ok {
		return rf(ctx, accountName, permissions)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []string) []*slurm.UserAccountAssociation); ok {
		r0 = rf(ctx, accountName, permissions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*slurm.UserAccountAssociation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []string) error); ok {
		r1 = rf(ctx, accountName, permissions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChildAccounts provides a mock function with given fields: ctx, accountName, depth
func (_m *MockAccountManager) GetChildAccounts(ctx context.Context, accountName string, depth int) ([]*slurm.Account, error) {
	ret := _m.Called(ctx, accountName, depth)

	if len(ret) == 0 {
		panic("no return value specified for GetChildAccounts")
	}

	var r0 []*slurm.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, int) ([]*slurm.Account, error)); ok {
		return rf(ctx, accountName, depth)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, int) []*slurm.Account); ok {
		r0 = rf(ctx, accountName, depth)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*slurm.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, int) error); ok {
		r1 = rf(ctx, accountName, depth)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetFairShareHierarchy provides a mock function with given fields: ctx, rootAccount
func (_m *MockAccountManager) GetFairShareHierarchy(ctx context.Context, rootAccount string) (*slurm.FairShareHierarchy, error) {
	ret := _m.Called(ctx, rootAccount)

	if len(ret) == 0 {
		panic("no return value specified for GetFairShareHierarchy")
	}

	var r0 *slurm.FairShareHierarchy
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*slurm.FairShareHierarchy, error)); ok {
		return rf(ctx, rootAccount)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *slurm.FairShareHierarchy); ok {
		r0 = rf(ctx, rootAccount)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.FairShareHierarchy)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, rootAccount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetParentAccounts provides a mock function with given fields: ctx, accountName
func (_m *MockAccountManager) GetParentAccounts(ctx context.Context, accountName string) ([]*slurm.Account, error) {
	ret := _m.Called(ctx, accountName)

	if len(ret) == 0 {
		panic("no return value specified for GetParentAccounts")
	}

	var r0 []*slurm.Account
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]*slurm.Account, error)); ok {
		return rf(ctx, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []*slurm.Account); ok {
		r0 = rf(ctx, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*slurm.Account)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// List provides a mock function with given fields: ctx, opts
func (_m *MockAccountManager) List(ctx context.Context, opts *slurm.ListAccountsOptions) (*slurm.AccountList, error) {
	ret := _m.Called(ctx, opts)

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 *slurm.AccountList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ListAccountsOptions) (*slurm.AccountList, error)); ok {
		return rf(ctx, opts)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *slurm.ListAccountsOptions) *slurm.AccountList); ok {
		r0 = rf(ctx, opts)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.AccountList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *slurm.ListAccountsOptions) error); ok {
		r1 = rf(ctx, opts)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Update provides a mock function with given fields: ctx, accountName, update
func (_m *MockAccountManager) Update(ctx context.Context, accountName string, update *slurm.AccountUpdate) error {
	ret := _m.Called(ctx, accountName, update)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *slurm.AccountUpdate) error); ok {
		r0 = rf(ctx, accountName, update)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ValidateUserAccess provides a mock function with given fields: ctx, userName, accountName
func (_m *MockAccountManager) ValidateUserAccess(ctx context.Context, userName string, accountName string) (*slurm.UserAccessValidation, error) {
	ret := _m.Called(ctx, userName, accountName)

	if len(ret) == 0 {
		panic("no return value specified for ValidateUserAccess")
	}

	var r0 *slurm.UserAccessValidation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*slurm.UserAccessValidation, error)); ok {
		return rf(ctx, userName, accountName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *slurm.UserAccessValidation); ok {
		r0 = rf(ctx, userName, accountName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*slurm.UserAccessValidation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, userName, accountName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewMockAccountManager creates a new instance of MockAccountManager. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAccountManager(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAccountManager {
	mock := &MockAccountManager{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
